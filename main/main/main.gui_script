local druid = require("druid.druid")
local events = require("event.events")
local gameEvents = require("main/events/gameEvents")
local playerModel = require("main/battle/playerModel")
local skills = require("main/battle/skills")
local enemyModel = require("main/battle/enemyModel")
local resourceType = require("main/battle/resourceType")
local buffs = require("main/battle/buffs")
local chats = require("main/battle/chats")
local gameModel = require("main/battle/gameModel")
local hitType = require("main/battle/hitType")
local dtypewriter = require ("main/utils/dtypewriter")
local settingsModel = require ("main/settings/settingsModel")
local achievements = require("main/achievements/achievements")

local function onPause(self)
	self.input_enabled = false
end

local function onResume(self)
	self.input_enabled = true
end

local function truncate(num, decimals)
	local mult = 10 ^ decimals
	return math.floor(num * mult) / mult
end

local function hideDot(self,dotNum)
	print("hidedot",dotNum)
	print(self["dot1"])
	gui.animate(self["dot"..dotNum], "color.w", 0, gui.EASING_LINEAR, 0.8)
end

local function showDot(self,dotNum)
	gui.animate(self["dot"..dotNum], "color.w", 1, gui.EASING_LINEAR, 0.8,0.2)
end

local function changeFace(self,bossCurr,bossNext)
	gui.play_flipbook(self.bossCurr,bossCurr)
	gui.play_flipbook(self.bossNext,bossNext)
	gui.set_alpha(self.bossNext, 0)
	gui.set_alpha(self.bossCurr, 1)

	gui.animate(self.bossCurr, "color.w", 0, gui.EASING_LINEAR, 1)
	gui.animate(self.bossNext, "color.w", 1, gui.EASING_LINEAR, 1)
end

local function updateBossIndicator(self)
	print("updateBossIndicator",self.dot1)
	if enemyModel.name == "boneca" then 
		hideDot(self,1)
		showDot(self,2)
		changeFace(self,"boneca_circle","frigo_circle")
	elseif enemyModel.name == "frigo" then
		hideDot(self,2)
		showDot(self,3)
		changeFace(self,"frigo_circle","dindin_circle")
	elseif enemyModel.name == "superDindin" then
		hideDot(self,3)
		showDot(self,4)
		changeFace(self,"dindin_circle","bombardiro_circle")
	elseif enemyModel.name == "patapim" then
		changeFace(self,"patapim_circle","bombardiro_circle")
	elseif enemyModel.name == "cappuccino" then
		changeFace(self,"cappuccino_circle","bombardiro_circle")
	end
end

local function onEnemyDie(self)
	updateBossIndicator(self)
	if enemyModel.name == "superDindin" then 
		achievements.setDindinDefeated(true)
	end
	if enemyModel.name == "bombardiro" then 
		timer.delay(1.5, false, function() 
			gui.set_color(self.flashEffectNode, vmath.vector4(0, 0, 0, 1))
			gui.set_alpha(self.flashEffectNode, 0)
			gui.animate(self.flashEffectNode, "color.w", 1, gui.EASING_LINEAR, 1,0,function()
				events.trigger(gameEvents.CHANGE_SCENE,"main","victory")
			end)
		end)
	end
end

local function onPlayerDie(self)
	gui.set_color(self.flashEffectNode, vmath.vector4(0, 0, 0, 1))
	gui.set_alpha(self.flashEffectNode, 0)
	achievements.setDeaths(achievements.deaths + 1)
	events.trigger(gameEvents.FADE_OUT_MUSIC,"#battleMusic")
	gui.animate(self.flashEffectNode, "color.w", 1, gui.EASING_LINEAR, 1,0,function()
		events.trigger(gameEvents.CHANGE_SCENE,"main","gameOver")
	end)
end

local function updateCds(self)
	for i = 1, 6 do
		local maxCd = playerModel.skills[i].maxCd
		local currentCd = playerModel.skills[i].cd

		currentCd = currentCd < maxCd and currentCd or maxCd
		local cdMarkerNode = self["cdMarker"..i]
		if currentCd > 0 then
			gui.set_enabled(cdMarkerNode, true)
			gui.set(cdMarkerNode, "size.y", 256*currentCd/maxCd)
		else
			gui.set_enabled(cdMarkerNode, false)
		end
	end
end

local function onPlayerStartCasting(self,skillId,castTime)
	events.trigger(gameEvents.PLAY_CAST)
	gui.set_enabled(self.playerCastNode, true)
		
	self.playerCastCountTarget = castTime
	self.playerCastSkill = skillId
end

local function onEnemyStartCasting(self, skillId, castTime)
	events.trigger(gameEvents.PLAY_CAST)
	gui.set_enabled(self.enemyCastNode, true)

	self.enemyCastCountTarget = castTime
	self.enemyCastSkill = skillId
end

local function finishPlayerCasting(self)
	events.trigger(gameEvents.STOP_CAST)

	gui.set_enabled(self.playerCastNode,false)
	print("fin",self.playerCastSkill)
	events.trigger(gameEvents.PLAYER_FINISH_CASTING, self.playerCastSkill)
	self.playerCastCountTarget = 0
	self.playerCastCount = 0
end

local function onInterruptPlayerCasting(self)
	events.trigger(gameEvents.STOP_CAST)
	gui.set_enabled(self.playerCastNode,false)
	self.playerCastCountTarget = 0
	self.playerCastCount = 0
end

local function finishEnemyCasting(self)
	events.trigger(gameEvents.STOP_CAST)
	gui.set_enabled(self.enemyCastNode,false)
	events.trigger(gameEvents.ENEMY_FINISH_CASTING, self.enemyCastSkill)
	self.enemyCastCountTarget = 0
	self.enemyCastCount = 0
end

local function onInterruptEnemyCasting(self)
	print("GUI INTERRUPT")
	events.trigger(gameEvents.STOP_CAST)
	gui.set_enabled(self.enemyCastNode,false)
	self.enemyCastCountTarget = 0
	self.enemyCastCount = 0
end
	
local function updatePlayerCast(self, dt)
	if self.playerCastCountTarget > 0 then
		local modifiedDt = playerModel.hasBuff(buffs.DARK_PATAPIM) and dt * 3 or dt
		self.playerCastCount = self.playerCastCount + modifiedDt
		self.playerCastBar:set_to(truncate(self.playerCastCount/self.playerCastCountTarget,4))
		if self.playerCastCount >= self.playerCastCountTarget then 
			finishPlayerCasting(self)
		end
	elseif gui.is_enabled(self.playerCastNode) then
		gui.set_enabled(self.playerCastNode, false)
	end
end

local function updateEnemyCast(self, dt)
	if self.enemyCastCountTarget > 0 then
		self.enemyCastCount = self.enemyCastCount + dt
		self.enemyCastBar:set_to(truncate(self.enemyCastCount/self.enemyCastCountTarget,4))
		if self.enemyCastCount >= self.enemyCastCountTarget then 
			finishEnemyCasting(self)
		end
	end
end

local function loadButtons(self)
	self.buttonLocks = {
		playerModel.skills[1].locked,
		playerModel.skills[2].locked,
		playerModel.skills[3].locked,
		playerModel.skills[4].locked,
		playerModel.skills[5].locked,
		playerModel.skills[6].locked
	}

	for i = 1, 6 do
		self["skillBtn"..i]:set_enabled(not self.buttonLocks[i])
		
		gui.play_flipbook(self["skillBtn"..i.."Node"], self.buttonLocks[i] and "EMPTY" or playerModel.skills[i].skillName)
		gui.set_text(self["skillBtnText"..i], self.buttonLocks[i] and "" or skills.getResourceCost(playerModel.skills[i].skillName))
		local yellow = vmath.vector4(1,1,0,1)
		local red = vmath.vector4(1,0,0,1)
		local blue = vmath.vector4(0,0,1,1)
	--	gui.set_color(self["skillBtnText"..i], red)
		if playerModel.currentCharacter == "patapim" then 
			--gui.set_color(self["skillBtnText"..i], blue)
		end
		if playerModel.currentCharacter == "cappuccino" then 
			--gui.set_color(self["skillBtnText"..i], yellow)
		end
	end

	if settingsModel.hotkeys == "123456" then 
		gui.set_text(self.hotkeyText1, "1")
		gui.set_text(self.hotkeyText2, "2")
		gui.set_text(self.hotkeyText3, "3")
		gui.set_text(self.hotkeyText4, "4")
		gui.set_text(self.hotkeyText5, "5")
		gui.set_text(self.hotkeyText6, "6")
	end

	if settingsModel.hotkeys == "QWERTY" then 
		gui.set_text(self.hotkeyText1, "Q")
		gui.set_text(self.hotkeyText2, "W")
		gui.set_text(self.hotkeyText3, "E")
		gui.set_text(self.hotkeyText4, "R")
		gui.set_text(self.hotkeyText5, "T")
		gui.set_text(self.hotkeyText6, "Y")
	end

	if settingsModel.hotkeys == "AZERTY" then 
		gui.set_text(self.hotkeyText1, "A")
		gui.set_text(self.hotkeyText2, "Z")
		gui.set_text(self.hotkeyText3, "E")
		gui.set_text(self.hotkeyText4, "R")
		gui.set_text(self.hotkeyText5, "T")
		gui.set_text(self.hotkeyText6, "Y")
	end
	
	gui.set_enabled(self.skillBtn6Node, playerModel.currentCharacter == "patapim")
	gui.set_visible(self.skillBtn6Node, playerModel.currentCharacter == "patapim")
end

local function updateButtons(self)
	local resource = playerModel.getResource()
	local enabledColor   = vmath.vector4(1, 1, 1, 1)
	local disabledColor = vmath.vector4(0.15, 0.15, 0.15, 0.8)
	local activeColor = vmath.vector4(0, 1, 0, 1)

	for i = 1, 6 do
		local btnNode = self["skillBtn" .. i .. "Node"]
		local cost    = skills.getResourceCost(playerModel.skills[i].skillName)
		local color   = enabledColor
		if hash(gui.get_flipbook(btnNode)) == hash(self.playerMod) then
			color = activeColor
		end
		if resource < cost then 
			color = disabledColor
		end
		if self.buttonLocks[i] then
			color = enabledColor
		end
		gui.set_color(btnNode, color)
	end
end

local function onFlashEffect(self,color)
	print("onFlashEffect")
	color["w"] = 0
	gui.set_color(self.flashEffectNode, color)
	
	gui.animate(self.flashEffectNode, "color.w", 1, gui.EASING_LINEAR, 0.1, 0,function() 
		gui.set(self.flashEffectNode, "color.w", 0)
	end)
end

local function onSetPlayerMod(self,mod)
	self.playerMod = mod
	updateButtons(self)
end

local function updateResourceBar(self)
	gui.set_enabled(self.playerResourceNode, playerModel.resourceType ~= resourceType.COMBOPOINT)
	gui.set_enabled(self.playerComboPointsNode, playerModel.resourceType == resourceType.COMBOPOINT)

	if playerModel.resourceType == resourceType.MANA then
		gui.set_color(self.playerResourceBarNode,vmath.vector4(0,0,1,1))
		self.playerResourceBar:set_to(playerModel.getResource()/playerModel.getMaxResource())
		gui.set_text(self.playerResourceTextNode, tostring(playerModel.getResource()).."/"..tostring(playerModel.getMaxResource()))
	elseif playerModel.resourceType == resourceType.RAGE then
		gui.set_color(self.playerResourceBarNode,vmath.vector4(1,0,0,1))
		self.playerResourceBar:set_to(playerModel.getResource()/playerModel.getMaxResource())
		gui.set_text(self.playerResourceTextNode, tostring(playerModel.getResource()).."/"..tostring(playerModel.getMaxResource()))
	elseif playerModel.resourceType == resourceType.COMBOPOINT then
		for i = 1, playerModel.getMaxResource() do
			if i > playerModel.combopoints then
				gui.set_alpha(self["cpHolder"..i], 0)
				gui.cancel_animation(self["cpHolder"..i], "color.w")
			end
		end
	end

	updateButtons(self)
end

local function onAddRage(self,value)
	playerModel.setRage(playerModel.rage + value)
	updateResourceBar(self)
end

local function onAddCp(self,value)
	if playerModel.resourceType == resourceType.COMBOPOINT then
		playerModel.setCp(playerModel.combopoints + value)
		gui.animate(self["cpHolder"..playerModel.combopoints], "color.w", 1, gui.EASING_LINEAR, 0.3)
		updateResourceBar(self)
	end
end

local function onSahurBtn(self)
	events.trigger(gameEvents.LOAD_SAHUR)
end

local function onPatapimBtn(self)
	events.trigger(gameEvents.LOAD_PATAPIM)
end

local function onCappucinoBtn(self)
	events.trigger(gameEvents.LOAD_CAPPUCINO)
end

local function updatePlayerHpText(self)
	gui.set_text(self.playerHpTextNode, tostring(playerModel.hp).."/"..tostring(playerModel.maxHp))
	self.playerHpBar:set_to(playerModel.hp/playerModel.maxHp)
end

local function updateEnemyHpText(self)
	gui.set_text(self.enemyHpTextNode, tostring(enemyModel.hp).."/"..tostring(enemyModel.maxHp))
	self.enemyHpBar:set_to(enemyModel.hp/enemyModel.maxHp)
end

local function loadPlayerIndicator(self)
	print(playerModel.currentCharacter)
	gui.play_flipbook(self.playerIndicator, playerModel.currentCharacter.."_circle")
end

local function onCharacterLoaded(self)
	loadPlayerIndicator(self)
	loadButtons(self)
	updatePlayerHpText(self)
	updateResourceBar(self)
end

local function onEnemyHurt(self,dmg)
	if not enemyModel.hasBuff(buffs.SHIELD) then
		enemyModel.setHp(enemyModel.hp-dmg.dmg)
		gameModel.setDamageDone(gameModel.damageDone + dmg.dmg)
		updateEnemyHpText(self)
		if enemyModel.hp <= 0 then
			events.trigger(gameEvents.ENEMY_DIE)
			onInterruptPlayerCasting(self)
			onInterruptEnemyCasting(self)
			--gameModel.setIsGameOver(true)
			gameModel.setEnemyEntered(false)
		end
	end
end

local function onPlayerHurt(self,dmg)
	if not playerModel.hasBuff(buffs.SHIELD) and not playerModel.hasBuff(buffs.EVASION) then
		playerModel.setHp(playerModel.hp-dmg.dmg)
		gameModel.setDamageTaken(gameModel.damageTaken + dmg.dmg)
		updatePlayerHpText(self)

		if playerModel.hp <= 0 and not gameModel.isGameOver then
			events.trigger(gameEvents.PLAYER_DIE)
			onInterruptPlayerCasting(self)
			onInterruptEnemyCasting(self)
			gameModel.setIsGameOver(true)
			gameModel.setEnemyEntered(false)
		end
	end
end

local function onPlayerHeal(self,amount)
	if playerModel.hp+amount >= playerModel.maxHp then
		playerModel.setHp(playerModel.maxHp)	
	else
		playerModel.setHp(playerModel.hp+amount)
	end
	
	updatePlayerHpText(self)
end

local function onEnemyHeal(self,amount)
	if enemyModel.hp+amount >= enemyModel.maxHp then
		enemyModel.setHp(enemyModel.maxHp)	
	else
		enemyModel.setHp(enemyModel.hp+amount)
	end

	updateEnemyHpText(self)
end


local function onMenuBtn(self)
	events.trigger(gameEvents.CHANGE_SCENE,"main","menu")
end

local function onPlayerHpMaxBtn(self)
	playerModel.setHp(playerModel.maxHp)
	updatePlayerHpText(self)
end

local function onResourceMaxBtn(self)
	playerModel.setResource(playerModel.getMaxResource())
	updateResourceBar(self)
end

local function onSkillBtn(self, skillIndex)
	if playerModel.getResource() >= skills.getResourceCost(playerModel.skills[skillIndex].skillName) 
	and playerModel.skills[skillIndex].cd <= 0 and playerModel.globalCd <= 0
	and not playerModel.hasBuff(buffs.STUN)
	and self.playerCastCountTarget == 0
	and not gameModel.isGameOver
	and not self.buttonLocks[skillIndex]
	and gameModel.enemyEntered
	then 
		events.trigger(gameEvents.TRIGGER_SKILL,playerModel.skills[skillIndex].skillName)
	else 
		events.trigger(gameEvents.PLAY_SFX,"#buttonlocked")
	end
end

local function onAllCritBtn(self)
	if self.allCrit then 
		playerModel.critPercent = 3
		self.allCrit = false
	else 
		playerModel.critPercent = 100
		self.allCrit = true
	end

	gui.set_text(gui.get_node("allCritText"), self.allCrit and "CRIT:ON" or "CRIT:OFF")
end

local function onSlowMoBtn(self)
	events.trigger(gameEvents.SLOW_MOTION,"main")
	if self.slowMo then 
		self.slowMo = false
	else 
		self.slowMo = true
	end

	gui.set_text(gui.get_node("slowMoText"), self.slowMo and "SLWMO:ON" or "SLWMO:OFF")
end

local function onPlayerHpMinusBtn(self)
	events.trigger(gameEvents.PLAYER_HURT,{dmg=10, crit=false},hitType.VFX.NONE,hitType.SFX.NONE)
end

local function onEnemyHpMinusBtn(self)
	events.trigger(gameEvents.ENEMY_HURT,{dmg=10, crit=false},hitType.VFX.NONE,hitType.SFX.NONE)
end

local function onEnemyHpMinusBtn2(self)
	events.trigger(gameEvents.ENEMY_HURT,{dmg=500, crit=false},hitType.VFX.NONE,hitType.SFX.NONE)
end


local function initGui(self)
	loadButtons(self)
	updatePlayerHpText(self)
	updateEnemyHpText(self)
	updateResourceBar(self)
	loadPlayerIndicator(self)
end

local function onEnemyEnter(self)
	local castBarPos = vmath.vector4(830,453,0,0)
	local chatBoxPos = vmath.vector4(830,529,0,0)
	if(enemyModel.castBarPos) then
		castBarPos.x = enemyModel.castBarPos[1]
		castBarPos.y = enemyModel.castBarPos[2]
		castBarPos.z = enemyModel.castBarPos[3]

		chatBoxPos.x = enemyModel.castBarPos[1]
	end
	
	gui.set_position(self.enemyCastNode,castBarPos)
	gui.set_position(self.chatBoxNode,chatBoxPos)
	updateEnemyHpText(self)

	if enemyModel.name == "patapim" then
		changeFace(self,"bombardiro_circle","patapim_circle")
	elseif enemyModel.name == "cappuccino" then
		changeFace(self,"bombardiro_circle","cappuccino_circle")
	end
end

local function onStartChat(self,dialogName, dialogIndex)
	if chats[dialogName] and chats[dialogName].seen == false then
		local di = dialogIndex or 1 
		local dialogs = chats[dialogName].en
		if di <= #dialogs then 
			events.trigger(gameEvents.PLAY_CHAT_SFX)
			dtypewriter.clear()
			dtypewriter.load(dialogs[di])
			dtypewriter.start()
			timer.delay(4, false, function() 
				onStartChat(self, dialogName, di+1)
			end)
		else 
			--events.trigger(gameEvents.play,"#dialogrev1")
			dtypewriter.clear()
			chats[dialogName].seen = true
			events.trigger(gameEvents.END_CHAT,dialogName)
		end
	else
		events.trigger(gameEvents.END_CHAT,dialogName)
	end
end

function init(self)
	self.druid = druid.new(self)
	self.input_enabled = true -- to handle pause
	self.sahurBtn = self.druid:new_button("sahurBtn", onSahurBtn)
	self.patapimBtn = self.druid:new_button("patapimBtn", onPatapimBtn)
	self.cappucinoBtn = self.druid:new_button("cappucinoBtn", onCappucinoBtn)
	self.menuBtn = self.druid:new_button("menuBtn", onMenuBtn)
	self.playerHpMaxBtn = self.druid:new_button("playerHpMaxBtn", onPlayerHpMaxBtn)
	self.resourceMaxBtn = self.druid:new_button("resourceMaxBtn", onResourceMaxBtn)
	self.allCritBtn = self.druid:new_button("allCritBtn", onAllCritBtn)
	self.slowMoBtn = self.druid:new_button("slowMoBtn", onSlowMoBtn)
	self.playerHpMinusBtn = self.druid:new_button("playerHpMinusBtn",onPlayerHpMinusBtn)
	self.enemyHpMinusBtn = self.druid:new_button("enemyHpMinusBtn",onEnemyHpMinusBtn)
	self.enemyHpMinusBtn2 = self.druid:new_button("enemyHpMinusBtn2",onEnemyHpMinusBtn2)

	self.playerMod = ""

	self.playerHpTextNode = gui.get_node("playerHpText")
	self.enemyHpTextNode = gui.get_node("enemyHpText")

	self.enemyHpBar = self.druid:new_progress("enemyHpBar", "x")
	self.enemyHpBar:set_to(1)

	self.flashEffectNode = gui.get_node("flashEffect")

	self.playerDead = false
	self.enemyDead = false
	self.gameOver = false

	events.subscribe(gameEvents.PLAYER_START_CASTING, onPlayerStartCasting, self)
	events.subscribe(gameEvents.CHARACTER_LOADED, onCharacterLoaded, self)
	events.subscribe(gameEvents.ENEMY_HURT, onEnemyHurt, self)
	events.subscribe(gameEvents.PLAYER_HURT, onPlayerHurt, self)
	events.subscribe(gameEvents.PLAYER_HEAL, onPlayerHeal, self)
	events.subscribe(gameEvents.ENEMY_HEAL, onEnemyHeal, self)
	events.subscribe(gameEvents.ADD_RAGE, onAddRage,self)
	events.subscribe(gameEvents.ADD_CP, onAddCp,self)
	events.subscribe(gameEvents.PAY_RESOURCE_COST, updateResourceBar,self)
	events.subscribe(gameEvents.SET_PLAYER_MOD, onSetPlayerMod,self)
	events.subscribe(gameEvents.ENEMY_START_CASTING, onEnemyStartCasting, self)
	events.subscribe(gameEvents.INTERRUPT_PLAYER_CASTING, onInterruptPlayerCasting, self)
	events.subscribe(gameEvents.INTERRUPT_ENEMY_CASTING, onInterruptEnemyCasting, self)
	events.subscribe(gameEvents.FLASH_EFFECT, onFlashEffect, self)
	events.subscribe(gameEvents.PLAYER_DIE, onPlayerDie, self)
	events.subscribe(gameEvents.ENEMY_DIE, onEnemyDie, self)
	events.subscribe(gameEvents.ENEMY_ENTER, onEnemyEnter, self)
	events.subscribe(gameEvents.START_CHAT, onStartChat, self)
	events.subscribe(gameEvents.PAUSE, onPause, self)
	events.subscribe(gameEvents.RESUME, onResume, self)
	

	self.playerHpBar = self.druid:new_progress("playerHpBar", "x")
	self.playerHpBar:set_to(1)

	self.playerResourceBar = self.druid:new_progress("playerResourceBar", "x")
	self.playerResourceBarNode = gui.get_node("playerResourceBar")
	self.playerResourceNode = gui.get_node("playerResource")
	self.playerComboPointsNode = gui.get_node("playerComboPoints")
	self.playerResourceTextNode = gui.get_node("playerResourceText")
	self.playerResourceBar:set_to(0)
	gui.set_text(self.playerResourceTextNode, tostring(playerModel.rage).."/"..tostring(playerModel.maxRage))

	for i = 1, 6 do
		self["skillBtn"..i] = self.druid:new_button("skillBtn"..i, onSkillBtn, i)
		self["skillBtn"..i.."Node"] = gui.get_node("skillBtn"..i)
		self["cdMarker"..i] = gui.get_node("cd"..i)
		self["skillBtnText"..i] = gui.get_node("skillBtnText"..i)
		self["hotkeyText"..i] = gui.get_node("hotkeyText"..i)
	end

	for i = 1, 5 do
		self["cpHolder"..i] = gui.get_node("cpFront"..i)
	end

	self.playerCastBar = self.druid:new_progress("playerCastBar", "x")
	self.playerCastNode = gui.get_node("playerCast")

	self.chatBoxNode = gui.get_node("chatBox")

	self.enemyCastBar = self.druid:new_progress("enemyCastBar", "x")
	self.enemyCastNode = gui.get_node("enemyCast")

	self.playerCastCount = 0
	self.playerCastCountTarget = 0

	self.enemyCastCountTarget = 0
	self.enemyCastCount = 0

	for i = 1, 4 do
		self["dot"..i] = gui.get_node("dot"..i.."Active")
	end	
	self.bossCurr = gui.get_node("bossCurr")
	self.bossNext = gui.get_node("bossNext")

	self.playerIndicator = gui.get_node("playerIndicator")
	
	dtypewriter.init("chatBox", "game", -400, 0, 800, 100, 1,"")

	initGui(self)
end

function final(self)
	self.druid:final()
	events.unsubscribe(gameEvents.PLAYER_START_CASTING, onPlayerStartCasting, self)
	events.unsubscribe(gameEvents.CHARACTER_LOADED, onCharacterLoaded, self)
	events.unsubscribe(gameEvents.ENEMY_HURT, onEnemyHurt, self)
	events.unsubscribe(gameEvents.PLAYER_HURT, onPlayerHurt, self)
	events.unsubscribe(gameEvents.PLAYER_HEAL, onPlayerHeal, self)
	events.unsubscribe(gameEvents.ENEMY_HEAL, onEnemyHeal, self)
	events.unsubscribe(gameEvents.ADD_RAGE, onAddRage,self)
	events.unsubscribe(gameEvents.PAY_RESOURCE_COST, updateResourceBar,self)
	events.unsubscribe(gameEvents.SET_PLAYER_MOD, onSetPlayerMod,self)
	events.unsubscribe(gameEvents.ADD_CP, onAddCp,self)
	events.unsubscribe(gameEvents.ENEMY_START_CASTING, onEnemyStartCasting, self)
	events.unsubscribe(gameEvents.INTERRUPT_PLAYER_CASTING, onInterruptPlayerCasting, self)
	events.unsubscribe(gameEvents.INTERRUPT_ENEMY_CASTING, onInterruptEnemyCasting, self)
	events.unsubscribe(gameEvents.FLASH_EFFECT, onFlashEffect, self)
	events.unsubscribe(gameEvents.PLAYER_DIE, onPlayerDie, self)
	events.unsubscribe(gameEvents.ENEMY_DIE, onEnemyDie, self)
	events.unsubscribe(gameEvents.ENEMY_ENTER, onEnemyEnter, self)
	events.unsubscribe(gameEvents.START_CHAT, onStartChat, self)
	events.unsubscribe(gameEvents.PAUSE, onPause, self)
	events.unsubscribe(gameEvents.RESUME, onResume, self)
end

function update(self, dt)
	self.druid:update(dt)
	if not self.gameOver then
		updatePlayerCast(self,dt)
		updateEnemyCast(self,dt)
		updateCds(self)
	end
end

function on_message(self, message_id, message, sender)
	self.druid:on_message(message_id, message, sender)
	if message_id == hash("complete") then
		events.trigger(gameEvents.STOP_CHAT_SFX)
	end
end

function on_input(self, action_id, action)
	if not self.input_enabled then
		return false
	end
	if settingsModel.hotkeys == "123456" then
		if action_id == hash("hotkey_1") and action.pressed then
			onSkillBtn(self,1)
		end
		if action_id == hash("hotkey_2") and action.pressed then
			onSkillBtn(self,2)
		end
		if action_id == hash("hotkey_3") and action.pressed then
			onSkillBtn(self,3)
		end
		if action_id == hash("hotkey_4") and action.pressed then
			onSkillBtn(self,4)
		end
		if action_id == hash("hotkey_5") and action.pressed then
			onSkillBtn(self,5)
		end
		if action_id == hash("hotkey_6") and action.pressed then
			onSkillBtn(self,6)
		end
	end

	if settingsModel.hotkeys == "QWERTY" then
		if action_id == hash("hotkey_Q") and action.pressed then
			onSkillBtn(self,1)
		end
		if action_id == hash("hotkey_W") and action.pressed then
			onSkillBtn(self,2)
		end
		if action_id == hash("hotkey_E") and action.pressed then
			onSkillBtn(self,3)
		end
		if action_id == hash("hotkey_R") and action.pressed then
			onSkillBtn(self,4)
		end
		if action_id == hash("hotkey_T") and action.pressed then
			onSkillBtn(self,5)
		end
		if action_id == hash("hotkey_Y") and action.pressed then
			onSkillBtn(self,6)
		end
	end

	if settingsModel.hotkeys == "AZERTY" then
		if action_id == hash("hotkey_A") and action.pressed then
			onSkillBtn(self,1)
		end
		if action_id == hash("hotkey_Z") and action.pressed then
			onSkillBtn(self,2)
		end
		if action_id == hash("hotkey_E") and action.pressed then
			onSkillBtn(self,3)
		end
		if action_id == hash("hotkey_R") and action.pressed then
			onSkillBtn(self,4)
		end
		if action_id == hash("hotkey_T") and action.pressed then
			onSkillBtn(self,5)
		end
		if action_id == hash("hotkey_Y") and action.pressed then
			onSkillBtn(self,6)
		end
	end
	
	return self.druid:on_input(action_id, action)
end