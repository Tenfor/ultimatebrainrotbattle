local druid = require("druid.druid")
local events = require("event.events")
local gameEvents = require("main/events/gameEvents")
local gameModel = require("main/battle/gameModel")
local enemyModel = require("main/battle/enemyModel")
local playerModel = require("main/battle/playerModel")
local upgradesModel = require("main/upgrades/upgradesModel")
local tutorial = require("main/tutorial/tutorial")
local achievements = require("main/achievements/achievements")
local storage = require("main/storage/storage")
local dtypewriter = require ("main/utils/dtypewriter")
local bridge = require("bridge.bridge")
local translator = require("main/translator/translator")

local function setUpTexts(self)
	local dmgDealt = math.floor(gameModel.damageDone/3)
	local dmgTaken = math.floor(gameModel.damageTaken/5)
	local enemiesDefeated = gameModel.enemiesDefeated * 20
	local incomeBonus = upgradesModel[playerModel.currentCharacter].income.values[upgradesModel[playerModel.currentCharacter].income.lvl+1]
	local total = math.floor((dmgDealt+dmgTaken+enemiesDefeated) * incomeBonus)
	upgradesModel[playerModel.currentCharacter].gold = upgradesModel[playerModel.currentCharacter].gold + total
	translator.translate({
		{node = "dmgDoneText", textId = "IDS_DAMAGE_DONE", args = {a=dmgDealt}},
		{node = "dmgTakenText", textId = "IDS_DAMAGE_TAKEN", args = {a=dmgTaken}},
		{node = "enemyText", textId = "IDS_ENEMIES_DEFEATED", args = {a=enemiesDefeated}},
		{node = "incomeBonusText", textId = "IDS_INCOME_BONUS", args = {a=incomeBonus}},
		{node = "totalText", textId = "IDS_TOTAL", args = {a=total}}
	})
	gui.play_flipbook(self.enemyNode, enemyModel.sprite)

	--TODO: SAVE HERE
end

local function showTexts(self)
	self.timer0 = timer.delay(.5, false, function() 
		events.trigger(gameEvents.PLAY_CHAT_SFX)
		
		dtypewriter.load(self.mock)
		dtypewriter.start()
	end)
	
	self.timer1 = timer.delay(1, false, function() 
		gui.set_enabled(self.continueBtnNode, true)
		gui.set_visible(self.dmgDoneTextNode, true)
		events.trigger(gameEvents.PLAY_SFX,"#coin_cling")
	end)
	self.timer2 = timer.delay(1.8, false, function() 
		gui.set_visible(self.dmgTakenTextNode, true)
		events.trigger(gameEvents.PLAY_SFX,"#coin_cling")
	end)
	self.timer3 = timer.delay(2.6, false, function() 
		gui.set_visible(self.enemyTextNode, true)
		events.trigger(gameEvents.PLAY_SFX,"#coin_cling")
	end)
	self.timer4 = timer.delay(3.4, false, function() 
		gui.set_visible(self.incomeTextNode, true)
		events.trigger(gameEvents.PLAY_SFX,"#coin_cling")
	end)
	self.timer5 = timer.delay(4.2, false, function() 
		gui.set_visible(self.totalTextNode, true)
		events.trigger(gameEvents.PLAY_SFX,"#coin_cling")
		self.textShowDone = true
	end)
end

local function skipTexts(self)
	self.textShowDone = true

	timer.cancel(self.timer0)
	timer.cancel(self.timer1)
	timer.cancel(self.timer2)
	timer.cancel(self.timer3)
	timer.cancel(self.timer4)
	timer.cancel(self.timer5)

	gui.set_visible(self.dmgDoneTextNode, true)
	gui.set_visible(self.dmgTakenTextNode, true)
	gui.set_visible(self.enemyTextNode, true)
	gui.set_visible(self.incomeTextNode, true)
	gui.set_visible(self.totalTextNode, true)

	events.trigger(gameEvents.PLAY_SFX,"#coin_cling")

	dtypewriter.skip()
end

local function onContinueBtn(self)
	if self.textShowDone then 		
	
		if not tutorial.tutorial2.seen then 
			tutorial.showUpgradesTut = true
		end
		bridge.advertisement.show_interstitial()
		--events.trigger(gameEvents.CHANGE_SCENE,"gameOver","upgrades")		
	else
		skipTexts(self)
	end
end

function init(self)
	self.druid = druid.new(self)

	local mockIndex = math.random(1,3)

	self.mock = translator.getText(enemyModel.mocks[mockIndex]).text

	translator.translate({"title", "label"})

	--gui.get_font(node)
	local font = gui.get_font_resource("game")
	local metrics = resource.get_text_metrics(font, self.mock)
	local xOffset = metrics.width / 2 > 600 and -600 or -metrics.width/2
	--dtypewriter.in
	dtypewriter.init("chatBox", "game", xOffset, 0, 1200, 100, 1,"")
	self.dmgDoneTextNode = gui.get_node("dmgDoneText")
	self.dmgTakenTextNode = gui.get_node("dmgTakenText")
	self.enemyTextNode = gui.get_node("enemyText")
	self.incomeTextNode = gui.get_node("incomeBonusText")
	self.totalTextNode = gui.get_node("totalText")

	self.enemyNode = gui.get_node("character")
	self.continueBtn = self.druid:new_button("continueBtn", onContinueBtn)
	self.continueBtnNode = gui.get_node("continueBtn")

	self.textShowDone = false

	bridge.advertisement.on("interstitial_state_changed", function (_, state)
		if state == "failed" then 
			bridge.platform.send_message("gameplay_started");
			events.trigger(gameEvents.CHANGE_SCENE,"gameOver","upgrades")		
			dtypewriter.clear()
			gameModel.reset()
		elseif state == "closed" then 
			bridge.platform.send_message("gameplay_started");
			events.trigger(gameEvents.CHANGE_SCENE,"gameOver","upgrades")		
			dtypewriter.clear()
			gameModel.reset()
		end
	end)

	bridge.platform.send_message("gameplay_stopped");

	achievements.setDeaths(achievements.deaths + 1)

	setUpTexts(self)

	showTexts(self)
	storage.saveData()
end

function final(self)
	self.druid:final()
end

function update(self, dt)
	self.druid:update(dt)
end

function on_message(self, message_id, message, sender)
	self.druid:on_message(message_id, message, sender)

	if message_id == hash("complete") then
		events.trigger(gameEvents.STOP_CHAT_SFX)
	end
end

function on_input(self, action_id, action)
	return self.druid:on_input(action_id, action)
end