local druid = require("druid.druid")
local upgradesModel = require("main/upgrades/upgradesModel")
local playerModel = require("main/battle/playerModel")
local events = require("event.events")
local gameEvents = require("main/events/gameEvents")
local tutorial = require("main/tutorial/tutorial")
local achievements = require("main/achievements/achievements")
local storage = require("main/storage/storage")
local bridge = require("bridge.bridge")
local translator = require("main/translator/translator")
local settingsModel = require("main/settings/settingsModel")

local function onTutorialShow(self)
	self.input_enabled = false
end

local function onTutorialHide(self)
	self.input_enabled = true
end

local function onShowFailedPanel(self)
	self.input_enabled = false
end

local function onHideFailedPanel(self)
	self.input_enabled = true
end

local function setDescription1(infoObj)
	if infoObj.name == "precision" then
		return infoObj.description
	end
	if infoObj.name == "str" then 
		local strObj = upgradesModel[playerModel.currentCharacter].str
		local curr = tostring(strObj.values[strObj.lvl + 1][1]).." - "..tostring(strObj.values[strObj.lvl + 1][2])
		local next = strObj.lvl < #strObj.prices and tostring(strObj.values[strObj.lvl + 2][1]).." - "..tostring(strObj.values[strObj.lvl + 2][2]) or ""
		local nextDesc = strObj.lvl >= #strObj.prices and "Max Level" or infoObj.descriptionNext
		local newDescription = infoObj.description.."\n"..nextDesc
		newDescription = string.gsub(newDescription,"{curr}",curr)
		newDescription = string.gsub(newDescription,"{next}",next)
		return newDescription
	end
	if infoObj.name == "pow" then 
		local powObj = upgradesModel[playerModel.currentCharacter].pow
		local curr = tostring(powObj.values[powObj.lvl + 1][1]).." - "..tostring(powObj.values[powObj.lvl + 1][2])
		local next = powObj.lvl < #powObj.prices and tostring(powObj.values[powObj.lvl + 2][1]).." - "..tostring(powObj.values[powObj.lvl + 2][2]) or ""
		local nextDesc = powObj.lvl >= #powObj.prices and "Max Level" or infoObj.descriptionNext
		local newDescription = infoObj.description.."\n"..nextDesc
		newDescription = string.gsub(newDescription,"{curr}",curr)
		newDescription = string.gsub(newDescription,"{next}",next)
		return newDescription
	end
	if infoObj.name == "hp" then 
		local hpObj = upgradesModel[playerModel.currentCharacter].hp
		local curr = tostring(hpObj.values[hpObj.lvl + 1])
		local next = hpObj.lvl < #hpObj.prices and tostring(hpObj.values[hpObj.lvl + 2]) or ""
		local nextDesc = hpObj.lvl >= #hpObj.prices and "Max Level" or infoObj.descriptionNext
		local newDescription = infoObj.description.."\n"..nextDesc
		newDescription = string.gsub(newDescription,"{curr}",curr)
		newDescription = string.gsub(newDescription,"{next}",next)
		return newDescription
	end
	if infoObj.name == "mana" then 
		local manaObj = upgradesModel[playerModel.currentCharacter].mana
		local curr = tostring(manaObj.values[manaObj.lvl + 1])
		local next = manaObj.lvl < #manaObj.prices and tostring(manaObj.values[manaObj.lvl + 2]) or ""
		local nextDesc = manaObj.lvl >= #manaObj.prices and "Max Level" or infoObj.descriptionNext
		local newDescription = infoObj.description.."\n"..nextDesc
		newDescription = string.gsub(newDescription,"{curr}",curr)
		newDescription = string.gsub(newDescription,"{next}",next)
		return newDescription
	end
	if infoObj.name == "crit" then 
		local critObj = upgradesModel[playerModel.currentCharacter].crit
		local curr = tostring(critObj.values[critObj.lvl + 1][1]).."%% - "..tostring(critObj.values[critObj.lvl + 1][2].."X")
		local next = critObj.lvl < #critObj.prices and tostring(critObj.values[critObj.lvl + 2][1]).."%% - "..tostring(critObj.values[critObj.lvl + 2][2].."X") or ""
		local nextDesc = critObj.lvl >= #critObj.prices and "Max Level" or infoObj.descriptionNext
		local newDescription = infoObj.description.."\n"..nextDesc
		newDescription = string.gsub(newDescription,"{curr}",curr)
		newDescription = string.gsub(newDescription,"{next}",next)
		return newDescription
	end
	if infoObj.name == "cdr" then 
		local cdrObj = upgradesModel[playerModel.currentCharacter].cdr
		local curr = tostring(cdrObj.values[cdrObj.lvl + 1])
		local next = cdrObj.lvl < #cdrObj.prices and tostring(cdrObj.values[cdrObj.lvl + 2]) or ""
		local nextDesc = cdrObj.lvl >= #cdrObj.prices and "Max Level" or infoObj.descriptionNext
		local newDescription = infoObj.description.."\n"..nextDesc
		newDescription = string.gsub(newDescription,"{curr}",curr)
		newDescription = string.gsub(newDescription,"{next}",next)
		return newDescription
	end
	if infoObj.name == "spd" then 
		local spdObj = upgradesModel[playerModel.currentCharacter].spd
		local curr = string.format("%.1f",spdObj.values[spdObj.lvl + 1]/3)
		local next = spdObj.lvl < #spdObj.prices and string.format("%.1f",spdObj.values[spdObj.lvl + 2]/3) or ""
		local nextDesc = spdObj.lvl >= #spdObj.prices and "Max Level" or infoObj.descriptionNext
		local newDescription = infoObj.description.."\n"..nextDesc
		newDescription = string.gsub(newDescription,"{curr}",curr)
		newDescription = string.gsub(newDescription,"{next}",next)
		return newDescription
	end
	if infoObj.name == "income" then 
		local incomeObj = upgradesModel[playerModel.currentCharacter].income
		local curr = tostring(incomeObj.values[incomeObj.lvl + 1])
		local next = incomeObj.lvl < #incomeObj.prices and tostring(incomeObj.values[incomeObj.lvl + 2]) or ""
		local nextDesc = incomeObj.lvl >= #incomeObj.prices and "Max Level" or infoObj.descriptionNext
		local newDescription = infoObj.description.."\n"..nextDesc
		newDescription = string.gsub(newDescription,"{curr}",curr)
		newDescription = string.gsub(newDescription,"{next}",next)
		return newDescription
	end
	if infoObj.name == "rage" then 
		local rageObj = upgradesModel[playerModel.currentCharacter].rage
		local curr = tostring(rageObj.values[rageObj.lvl + 1])
		local next = rageObj.lvl < #rageObj.prices and tostring(rageObj.values[rageObj.lvl + 2]) or ""
		local nextDesc = rageObj.lvl >= #rageObj.prices and "Max Level" or infoObj.descriptionNext
		local newDescription = infoObj.description.."\n"..nextDesc
		newDescription = string.gsub(newDescription,"{curr}",curr)
		newDescription = string.gsub(newDescription,"{next}",next)
		return newDescription
	end
	return infoObj.description
end

local function getDescription(infoObj)
	if infoObj.name == "str" then 
		local strObj = upgradesModel[playerModel.currentCharacter].str
		return {
			node = "desc",
			textId = strObj.lvl >= #strObj.prices and "IDS_STR_MAX_DESC" or "IDS_STR_DESC",
			args = strObj.lvl >= #strObj.prices and {
				a = strObj.values[strObj.lvl + 1][1],
				b = strObj.values[strObj.lvl + 1][2],
			} 
			or {
				a = strObj.values[strObj.lvl + 1][1],
				b = strObj.values[strObj.lvl + 1][2],
				c = strObj.values[strObj.lvl + 2][1],
				d = strObj.values[strObj.lvl + 2][2]
			}
		}
	end
	if infoObj.name == "pow" then 
		local powObj = upgradesModel[playerModel.currentCharacter].pow
		return {
			node = "desc",
			textId = powObj.lvl >= #powObj.prices and "IDS_POW_MAX_DESC" or "IDS_POW_DESC",
			args = powObj.lvl >= #powObj.prices and {
				a = powObj.values[powObj.lvl + 1][1],
				b = powObj.values[powObj.lvl + 1][2],
			} 
			or {
				a = powObj.values[powObj.lvl + 1][1],
				b = powObj.values[powObj.lvl + 1][2],
				c = powObj.values[powObj.lvl + 2][1],
				d = powObj.values[powObj.lvl + 2][2]
			}
		}
	end
	if infoObj.name == "spd" then 
		local spdObj = upgradesModel[playerModel.currentCharacter].spd
		return {
			node = "desc",
			textId = spdObj.lvl >= #spdObj.prices and "IDS_SPD_MAX_DESC" or "IDS_SPD_DESC",
			args = spdObj.lvl >= #spdObj.prices and {
				a = string.format("%.1f",spdObj.values[spdObj.lvl + 1]/3)
			} 
			or {
				a = string.format("%.1f",spdObj.values[spdObj.lvl + 1]/3),
				b = string.format("%.1f",spdObj.values[spdObj.lvl + 2]/3)
			}
		}
	end
	if infoObj.name == "hp" then 
		local hpObj = upgradesModel[playerModel.currentCharacter].hp
		return {
			node = "desc",
			textId = hpObj.lvl >= #hpObj.prices and "IDS_HP_MAX_DESC" or "IDS_HP_DESC",
			args = hpObj.lvl >= #hpObj.prices and {
				a = hpObj.values[hpObj.lvl + 1],
			} 
			or {
				a = hpObj.values[hpObj.lvl + 1],
				b = hpObj.values[hpObj.lvl + 2],
			}
		}
	end
	if infoObj.name == "crit" then 
		local critObj = upgradesModel[playerModel.currentCharacter].crit
		return {
			node = "desc",
			textId = critObj.lvl >= #critObj.prices and "IDS_CRIT_MAX_DESC" or "IDS_CRIT_DESC",
			args = critObj.lvl >= #critObj.prices and {
				a = critObj.values[critObj.lvl + 1][1],
				b = critObj.values[critObj.lvl + 1][2],
			} 
			or {
				a = critObj.values[critObj.lvl + 1][1],
				b = critObj.values[critObj.lvl + 1][2],
				c = critObj.values[critObj.lvl + 2][1],
				d = critObj.values[critObj.lvl + 2][2],
			}
		}
	end
	if infoObj.name == "income" then 
		local incomeObj = upgradesModel[playerModel.currentCharacter].income
		return {
			node = "desc",
			textId = incomeObj.lvl >= #incomeObj.prices and "IDS_INCOME_MAX_DESC" or "IDS_INCOME_DESC",
			args = incomeObj.lvl >= #incomeObj.prices and {
				a = incomeObj.values[incomeObj.lvl + 1],
			} 
			or {
				a = incomeObj.values[incomeObj.lvl + 1],
				b = incomeObj.values[incomeObj.lvl + 2],
			}
		}
	end
	if infoObj.name == "rage" then 
		local rageObj = upgradesModel[playerModel.currentCharacter].rage
		return {
			node = "desc",
			textId = rageObj.lvl >= #rageObj.prices and "IDS_RAGE_MAX_DESC" or "IDS_RAGE_DESC",
			args = rageObj.lvl >= #rageObj.prices and {
				a = rageObj.values[rageObj.lvl + 1],
			} 
			or {
				a = rageObj.values[rageObj.lvl + 1],
				b = rageObj.values[rageObj.lvl + 2],
			}
		}
	end
	if infoObj.name == "mana" then 
		local manaObj = upgradesModel[playerModel.currentCharacter].mana
		return {
			node = "desc",
			textId = manaObj.lvl >= #manaObj.prices and "IDS_MANA_MAX_DESC" or "IDS_MANA_DESC",
			args = manaObj.lvl >= #manaObj.prices and {
				a = manaObj.values[manaObj.lvl + 1],
			} 
			or {
				a = manaObj.values[manaObj.lvl + 1],
				b = manaObj.values[manaObj.lvl + 2],
			}
		}
	end
	if infoObj.name == "cdr" then 
		local cdrObj = upgradesModel[playerModel.currentCharacter].cdr
		return {
			node = "desc",
			textId = cdrObj.lvl >= #cdrObj.prices and "IDS_CDR_MAX_DESC" or "IDS_CDR_DESC",
			args = cdrObj.lvl >= #cdrObj.prices and {
				a = cdrObj.values[cdrObj.lvl + 1],
			} 
			or {
				a = cdrObj.values[cdrObj.lvl + 1],
				b = cdrObj.values[cdrObj.lvl + 2],
			}
		}
	end
	if infoObj.name == "precision" then 
		local precisionObj = upgradesModel[playerModel.currentCharacter].precision
		return {
			node = "desc",
			textId = precisionObj.lvl >= #precisionObj.prices and "IDS_PRECISION_MAX_DESC" or "IDS_PRECISION_DESC",
		}
	end

	return {node = "desc", textId = infoObj.description}
end

local function setInfo(self,name)
	local infoObj = upgradesModel.sahur[name]
	
	if playerModel.currentCharacter == "patapim" then
		infoObj = upgradesModel.patapim[name]
	elseif playerModel.currentCharacter == "cappuccino" then
		infoObj = upgradesModel.cappuccino[name]
	end
	
	if infoObj ~= nil then 
		--gui.set_text(self.titleNode, infoObj.title)
		local descElement = {
			node = "desc"
		}
		translator.translate({
			{node="title",args={},textId=infoObj.title},
			getDescription(infoObj),
			{
				node="lvl",
				textId = infoObj.lvl >= #infoObj.prices and "IDS_MAX_LEVEL" or "IDS_LEVEL", 
				args = infoObj.lvl >= #infoObj.prices and {} or {a = infoObj.lvl, b = #infoObj.prices}
			}
		})

		--local description = setDescription(infoObj)
		
	--	gui.set_text(self.descNode, description)
	
		
		if infoObj.lvl >= #infoObj.prices then
			if gui.is_enabled(self.buyBtnNode) then 
				gui.set_enabled(self.buyBtnNode, false)
			end
		else
			if not gui.is_enabled(self.buyBtnNode) then 
				gui.set_enabled(self.buyBtnNode, true)
			end
			gui.set_text(self.priceNode,infoObj.prices[infoObj.lvl+1])
		end
	end
end

local function onUpgradeSelect(self,name)
	self.selectedUpgrade = name
	setInfo(self,name)
end

local function onMenuBtn(self)
	events.trigger(gameEvents.CHANGE_SCENE,"upgrades","menu")
end

local function onBattleBtn(self)
	events.trigger(gameEvents.CHANGE_SCENE,"upgrades","main")
end


local function initAdReward(self)
	local maxBoss = achievements.sahurMaxBoss
	local adReward = 20
	if playerModel.currentCharacter == "patapim" then
		maxBoss = achievements.patapimMaxBoss
	end
	if playerModel.currentCharacter == "cappuccino" then
		maxBoss = achievements.cappuccinoMaxBoss
	end
	if maxBoss == 1 then 
		adReward = 50
	elseif maxBoss == 2 then
		adReward = 100
	elseif maxBoss == 3 then
		adReward = 200
	elseif maxBoss == 4 then 
		adReward = 500
	end

	local incomeBonus = upgradesModel[playerModel.currentCharacter].income.values[upgradesModel[playerModel.currentCharacter].income.lvl+1]
	self.adReward = math.floor(adReward * incomeBonus)

	translator.translate({
		{node = "adRewardText", args={a=self.adReward}, textId = "IDS_AD_REWARD"}
	})
end

local function updateTexts(self)
	for i = 1, 6 do
		local stat = upgradesModel[playerModel.currentCharacter].listedStats[i]
		local lvl = upgradesModel[playerModel.currentCharacter][stat].lvl
		local maxLvl = #upgradesModel[playerModel.currentCharacter][stat].prices
		gui.set_enabled(self["stat"..i.."Max"], lvl == maxLvl)
		gui.set_text(self["stat"..i.."Lvl"], lvl.."/"..maxLvl)
		if lvl == maxLvl or upgradesModel[playerModel.currentCharacter].gold >= upgradesModel[playerModel.currentCharacter][stat].prices[lvl+1] then
			gui.set_color(self["stat"..i.."Node"], vmath.vector4(1,1,1,1))
		else
			gui.set_color(self["stat"..i.."Node"], vmath.vector4(0.2,0.2,0.2,1))
		end
	end

	translator.translate({
		{node = "goldText", args={a=upgradesModel[playerModel.currentCharacter].gold}, textId = "IDS_GOLD"}
	})

	for i = 1, 5 do
		local lvl = upgradesModel[playerModel.currentCharacter]["skill"..i].lvl
		gui.set_enabled(self["skill"..i.."Max"], lvl == 1)
		gui.set_text(self["skill"..i.."Lvl"], lvl.."/"..1)
		if upgradesModel[playerModel.currentCharacter].gold >= upgradesModel[playerModel.currentCharacter]["skill"..i].prices[1] or lvl == 1 then
			gui.set_color(self["skill"..i.."Node"], vmath.vector4(1,1,1,1))
		else
			gui.set_color(self["skill"..i.."Node"], vmath.vector4(0.2,0.2,0.2,1))
		end
	end

	if playerModel.currentCharacter == "patapim" then
		local lvl = upgradesModel[playerModel.currentCharacter]["skill6"].lvl
		gui.set_text(self["skill6Lvl"], lvl.."/"..1)
		gui.set_enabled(self["skill6Max"], lvl == 1)
		if upgradesModel[playerModel.currentCharacter].gold >= upgradesModel[playerModel.currentCharacter]["skill6"].prices[1] or lvl == 1 then
			gui.set_color(self["skill6Node"], vmath.vector4(1,1,1,1))
		else
			gui.set_color(self["skill6Node"], vmath.vector4(0.2,0.2,0.2,1))
		end
	end

	initAdReward(self)
end

local function onBuyBtn(self)
	local infoObj = upgradesModel.sahur[self.selectedUpgrade]

	if playerModel.currentCharacter == "patapim" then
		infoObj = upgradesModel.patapim[self.selectedUpgrade]
	elseif playerModel.currentCharacter == "cappuccino" then
		infoObj = upgradesModel.cappuccino[self.selectedUpgrade]
	end

	if infoObj ~= nil then 
		if upgradesModel[playerModel.currentCharacter].gold >= infoObj.prices[infoObj.lvl+1] then
			upgradesModel[playerModel.currentCharacter].gold = upgradesModel[playerModel.currentCharacter].gold - infoObj.prices[infoObj.lvl+1]
			infoObj.lvl = infoObj.lvl + 1
			events.trigger(gameEvents.PLAY_SFX,"#buy")
			setInfo(self, self.selectedUpgrade)
			storage.saveData()
			updateTexts(self)
		else
			events.trigger(gameEvents.PLAY_SFX,"#buttonlocked")
		end
	end
end

local function showPatapimSkills(self)
	self["skill6Btn"] = self.druid:new_button("skill6Btn", onUpgradeSelect, "skill6")
	self["skill6Lvl"] = gui.get_node("skill6Lvl")
	self["skill6Node"] = gui.get_node("skill6Btn")
	self["skill6Max"] = gui.get_node("skill6Max")

	for i = 1, 5 do
		local node = gui.get_node("skill"..i.."Box")
		local pos = gui.get_position(node)
		pos.x = 150 + (i-1) * 130
		gui.set_position(node, pos)
	end

	gui.play_flipbook(gui.get_node("skill6Btn"), "COMET_RAIN")
	gui.set_enabled(gui.get_node("skill6Box"), true)
end

local function onFailedPanelContinueBtn(self)
	gui.set_enabled(self.failedPanel, false)
end

local function onWatchAdBtn(self)
	bridge.advertisement.show_rewarded()
end

local function translate()
	translator.translate({
		"header",
		"title",
		"desc",
		"text3",
		"text4",
		{node = "goldText", args = {a=upgradesModel[playerModel.currentCharacter].gold}, textId="IDS_GOLD"},
		"buyBtnLabel"
		--s{node = "adRewardText", args = {a=self.adReward}, textId="IDS_AD_REWARD"},
	})
end

function init(self)
	self.druid = druid.new(self)
	
	for i = 1, 6 do
		local stat = upgradesModel[playerModel.currentCharacter].listedStats[i]
		self["stat"..i.."Btn"] = self.druid:new_button("stat"..i.."Btn", onUpgradeSelect, stat)
		self["stat"..i.."Lvl"] = gui.get_node("stat"..i.."Lvl")
		self["stat"..i.."Node"] = gui.get_node("stat"..i.."Btn")
		self["stat"..i.."Max"] = gui.get_node("stat"..i.."Max")
		gui.play_flipbook(self["stat"..i.."Node"], stat)
	end

	for i = 1, 5 do
		local sprite = upgradesModel[playerModel.currentCharacter]["skill"..i].sprite
		self["skill"..i.."Btn"] = self.druid:new_button("skill"..i.."Btn", onUpgradeSelect, "skill"..i)
		self["skill"..i.."Lvl"] = gui.get_node("skill"..i.."Lvl")
		self["skill"..i.."Node"] = gui.get_node("skill"..i.."Btn")
		self["skill"..i.."Max"] = gui.get_node("skill"..i.."Max")
		gui.play_flipbook(gui.get_node("skill"..i.."Btn"), sprite)
	end

	if playerModel.currentCharacter == "patapim" then
		showPatapimSkills(self)
	end
	
	self.buyBtn = self.druid:new_button("buyBtn", onBuyBtn)
--	self.addGoldBtn = self.druid:new_button("addGold", onAddGoldBtn)
	self.buyBtnNode = gui.get_node("buyBtn")

	self.menuBtn = self.druid:new_button("menuBtn", onMenuBtn)
	self.battleBtn = self.druid:new_button("battleBtn", onBattleBtn)

	self.titleNode = gui.get_node("title")
	self.lvlNode = gui.get_node("lvl")
	self.descNode = gui.get_node("desc")
	self.priceNode = gui.get_node("price")
	self.goldTextNode = gui.get_node("goldText")

	self.watchAdBtn = self.druid:new_button("watchAd", onWatchAdBtn)
	self.watchAdBtnNode = gui.get_node("watchAd")
	self.adRewardText = gui.get_node("adRewardText")

	gui.set_enabled(self.watchAdBtnNode, upgradesModel.canWatchAd and not settingsModel.hideAds)
	
	--createBoxes(self)
	--initAdReward(self)
	updateTexts(self)

	self.header = gui.get_node("header")
	if playerModel.currentCharacter == "sahur" then 
		gui.set_text(self.header, "IDS_SAHUR_UPGRADES")
	elseif playerModel.currentCharacter == "patapim" then
		gui.set_text(self.header, "IDS_PATAPIM_UPGRADES")
	elseif playerModel.currentCharacter == "cappuccino" then
		gui.set_text(self.header, "IDS_CAPPUCCINO_UPGRADES")
	end

	events.trigger(gameEvents.PLAY_MUSIC,"#menuMusic")

	self.input_enabled = true
	events.subscribe(gameEvents.SHOW_TUTORIAL, onTutorialShow, self)
	events.subscribe(gameEvents.HIDE_TUTORIAL, onTutorialHide, self)
	events.subscribe(gameEvents.SHOW_FAILED_PANEL, onShowFailedPanel, self)
	events.subscribe(gameEvents.HIDE_FAILED_PANEL, onHideFailedPanel, self)

	if not tutorial.tutorial2.seen and tutorial.showUpgradesTut then
			tutorial.showUpgradesTut = false
			events.trigger(gameEvents.SHOW_TUTORIAL,"tutorial2")
	end

	bridge.advertisement.on("rewarded_state_changed", function (_, state)
		if state == "opened" then 
			self.input_enabled = false
			events.trigger(gameEvents.STOP_MUSIC,"#menuMusic")
		elseif state == "rewarded" then 
			upgradesModel[playerModel.currentCharacter].gold = upgradesModel[playerModel.currentCharacter].gold + self.adReward
			updateTexts(self)
			gui.set_enabled(self.watchAdBtnNode, false)
			upgradesModel.canWatchAd = false
		elseif state == "failed" then 
			events.trigger(gameEvents.SHOW_FAILED_PANEL)
		elseif state == "closed" then 
			self.input_enabled = true
			events.trigger(gameEvents.PLAY_MUSIC,"#menuMusic")
			--msg.post("game:/soundController", "playMusic", {url = "#menuMusic"} )
		end
	end)

	translate()
end

function final(self)
	self.druid:final()
	events.unsubscribe(gameEvents.SHOW_TUTORIAL, onTutorialShow, self)
	events.unsubscribe(gameEvents.HIDE_TUTORIAL, onTutorialHide, self)
	events.unsubscribe(gameEvents.SHOW_FAILED_PANEL, onShowFailedPanel, self)
	events.unsubscribe(gameEvents.HIDE_FAILED_PANEL, onHideFailedPanel, self)
end

function update(self, dt)
	self.druid:update(dt)
end

function on_message(self, message_id, message, sender)
	self.druid:on_message(message_id, message, sender)
end

function on_input(self, action_id, action)
	if not self.input_enabled then 
		return false
	end
	return self.druid:on_input(action_id, action)
end